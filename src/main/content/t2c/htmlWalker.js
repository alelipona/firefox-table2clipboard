/*
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is
# Davide Ficano.
# Portions created by the Initial Developer are Copyright (C) 2009
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Davide Ficano <davide.ficano@gmail.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
*/
function Table2ClipHtmlWalker(prefs) {
    this.htmlText = "";
    this.fCanonical = false;
    this.fXML11 = false;

    // Used to determine if doctype to write is generated by
    // node.DOCUMENT_NODE or node.DOCUMENT_TYPE_NODE
    // Delay doctype output until node.DOCUMENT_NODE and node.DOCUMENT_TYPE_NODE
    // are processed.
    // node.DOCUMENT_TYPE_NODE can be absent so node.DOCUMENT_NODE is used.
    this.doctypeString = "";
    this.nodeHandlers = [];
    this.nodeHandlers['a'] = this.handleTagA;
    this.prefs = prefs;
    this.copyStyle = this.prefs.getBool(T2CLIP_COPY_STYLE);
}

Table2ClipHtmlWalker.prototype = {
    print : function(str) {
        this.htmlText += str;
    },
    
    println : function(str) {
        this.htmlText += str + "\n";
    },

    handleDoctype : function() {
        if (this.doctypeString != "") {
            this.print(this.doctypeString);
            this.doctypeString = "";
        }
    },

    getVersion : function(doc) {
        return null;
    },

    handleTagA : function(walker, node) {
        var href = node.getAttribute('href');
        var uri = Components
            .classes["@mozilla.org/network/standard-url;1"]
            .createInstance(Components.interfaces.nsIURL);
        uri.spec = window.content.document.location;
    
        walker.print(' ');
        walker.print('href');
        walker.print('="');
    
        walker.normalizeAndPrint(uri.resolve(href), true);
        walker.print('"');
        
        return {skipNode : false,
                skipChildren : false,
                skipAttributes : true};
    },

    getNodeInfo : function(node) {
        var handler = this.nodeHandlers[node.localName.toLowerCase()];
        if (handler) {
            return handler(this, node);
        }
        return {skipNode : false,
                skipChildren : false,
                skipAttributes : false};
    },
    
    walk : function(node) {
        // is there anything to do?
        if (node == null) {
            return;
        }

        var type = node.nodeType;

        switch (type) {
            case node.ELEMENT_NODE: {
                var style = node.ownerDocument.defaultView.getComputedStyle(node, null);
                if (style.getPropertyValue("display") == "none") {
                    return;
                }
                var nodeInfo = this.getNodeInfo(node);
                if (nodeInfo.skipNode) {
                    return;
                }
                this.handleDoctype();
                this.print('<');
                this.print(node.nodeName);

                if  (!nodeInfo.skipAttributes) {
                    var attrs = node.attributes;
                    for (var i = 0; i < attrs.length; i++) {
                        var attr = attrs[i];
                        this.print(' ');
                        this.print(attr.nodeName);
                        this.print('="');
    
                        this.normalizeAndPrint(attr.nodeValue, true);
                        this.print('"');
                    }
                }
                if (this.copyStyle) {
                    this.print(' style="' + this.getStyleText(style) + '"');
                }
                this.print('>');

                if (!nodeInfo.skipChildren) {
                    var child = node.firstChild;
                    while (child != null) {
                        this.walk(child);
                        child = child.nextSibling;
                    }
                }
                break;
            }

            case node.ENTITY_REFERENCE_NODE: {
                if (this.fCanonical) {
                    var child = node.firstChild;
                    while (child != null) {
                        this.walk(child);
                        child = child.nextSibling;
                    }
                }
                else {
                    this.print('&');
                    this.print(node.nodeName);
                    this.print(';');
                }
                break;
            }

            case node.CDATA_SECTION_NODE: {
                if (this.fCanonical) {
                    this.normalizeAndPrint(node.nodeValue, false);
                }
                else {
                    this.print("<![CDATA[");
                    this.print(node.nodeValue);
                    this.print("]]>");
                }
                break;
            }

            case node.TEXT_NODE: {
                this.normalizeAndPrint(node.nodeValue, false);
                break;
            }

            case node.PROCESSING_INSTRUCTION_NODE: {
                this.print("<?");
                this.print(node.nodeName);

                var data = node.nodeValue;
                if (data != null && data.length > 0) {
                    this.print(' ');
                    this.print(data);
                }
                this.println("?>");
                break;
            }

            case node.COMMENT_NODE: {
                this.handleDoctype();
                if (!this.fCanonical) {
                    this.print("<!--");
                    var comment = node.nodeValue;
                    if (comment != null && comment.length > 0) {
                        this.print(comment);
                    }
                    this.println("-->");
                }
            }
        }

        if (type == Node.ELEMENT_NODE) {
                this.print("</");
                this.print(node.nodeName);
                this.print('>');
        }
    },

    getStyleText : function(style) {
        var computed = "";
        for (var i = 0; i < style.length; i++) {
            var cssPropName = style.item(i);
            computed += cssPropName + ":" + style.getPropertyValue(cssPropName) + ";";
        }
        
        return computed;
    },
    
    /** Normalizes and prints the given string. */
    normalizeAndPrint : function(s, isAttValue) {
        var len = (s != null) ? s.length : 0;
        for (var i = 0; i < len; i++) {
            var c = s.charAt(i);
            this.normalizeAndPrintChar(c, isAttValue);
        }

    },

    /** Normalizes and print the given character. */
    normalizeAndPrintChar : function(c, isAttValue) {
        switch (c) {
            case '<': {
                this.print("&lt;");
                break;
            }
            case '>': {
                this.print("&gt;");
                break;
            }
            case '&': {
                this.print("&amp;");
                break;
            }
            case '"': {
                // A '"' that appears in character data
                // does not need to be escaped.
                if (isAttValue) {
                    this.print("&quot;");
                }
                else {
                    this.print("\"");
                }
                break;
            }
            case '\r': {
            	// If CR is part of the document's content, it
            	// must not be printed as a literal otherwise
            	// it would be normalized to LF when the document
            	// is reparsed.
            	this.print("&#xD;");
            	break;
            }
            case '\n': {
                if (this.fCanonical) {
                    this.print("&#xA;");
                    break;
                }
                // else, default print char
            }
            default: {
                this.print(c);
            }
        }
    },

    toHtml : function() {
        return this.htmlText;
    }
}